(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["sigil"] = factory();
	else
		root["sigil"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var snabbdom = __webpack_require__(1);
	var h = __webpack_require__(2);
	var PropertyModule = __webpack_require__(3);
	var AttributesModule = __webpack_require__(4);
	var EventListenersModule = __webpack_require__(5);
	var classNames = __webpack_require__(6);

	var patch = snabbdom.init([PropertyModule, AttributesModule, EventListenersModule]);

	function createExpression(expression) {
	  var expression = expression.trim();
	  expression = expression.replace(/:[\w-_]+/g, function (name) {
	    return "this.$evaluateProp(\"" + name.substr(1) + "\")";
	  });
	  expression = expression.replace(/#[\w-_]+/g, function (name) {
	    return "this.$evaluateAttribute(\"" + name.substr(1) + "\")";
	  });
	  if (expression.trim() === "") {
	    expression = "\"\"";
	  }
	  return expression;
	}

	function createList(listExpression, h) {
	  var split = listExpression.split("in");
	  var varName = split[0];
	  var input = createExpression(split[1]);
	  return "(function(){var $results = []; var $inputs=" + input + "; if($inputs !== undefined && $inputs !== null){for(var $i=0;$i<$inputs.length;$i++){$results.push((function($inputs,$index){ var " + varName + " = $inputs[$index];return " + h + ";})($inputs,$i))}} return $results;}).call(this)";
	}

	function createTextChild(node) {
	  var text = node.textContent.replace(/{{\s*[\S\s]+\s*}}/g, function () {
	    var expression = arguments[0].substr(2, arguments[0].length - 4);
	    return "\"+" + createExpression(expression) + "+\"";
	  });
	  text = text.replace(/\n/g, "\\n");
	  return "\"" + text + "\"";
	}

	function createTreeChild(node) {
	  if (node.nodeName === "#comment") {
	    return "null";
	  }
	  if (node.nodeName === "#text") {
	    return createTextChild(node);
	  }

	  var conditionalExpression = null;
	  var ifValue = node.getAttribute("%if");
	  if (ifValue !== null) {
	    conditionalExpression = createExpression(ifValue);
	  }

	  var listExpression = null;
	  var listValue = node.getAttribute("%for");
	  if (listValue !== null) {
	    listExpression = listValue;
	  }

	  var children = [];
	  for (var i = 0; i < node.childNodes.length; i++) {
	    children.push(createTreeChild(node.childNodes[i]));
	  }

	  var attributePairs = [];
	  var propertyPairs = [];
	  var eventPairs = [];
	  for (var i = 0; i < node.attributes.length; i++) {
	    if (node.attributes[i].nodeName[0] == "#") {
	      var pair = "\"" + node.attributes[i].nodeName.substr(1) + "\":";
	      pair += createExpression(node.attributes[i].nodeValue);
	      attributePairs.push(pair);
	    } else if (node.attributes[i].nodeName[0] == ":") {
	      var pair = "\"" + node.attributes[i].nodeName.substr(1) + "\":";
	      pair += createExpression(node.attributes[i].nodeValue);
	      propertyPairs.push(pair);
	    } else if (node.attributes[i].nodeName[0] == "@") {
	      var pair = "\"" + node.attributes[i].nodeName.substr(1) + "\":";
	      pair += '(function($event){ ' + createExpression(node.attributes[i].nodeValue) + ' }).bind(this)';
	      eventPairs.push(pair);
	    } else if (node.attributes[i].nodeName[0] == "%") {
	      continue;
	    } else {
	      var pair = "\"" + node.attributes[i].nodeName + "\":";
	      pair += "\"" + node.attributes[i].nodeValue + "\"";
	      attributePairs.push(pair);
	    }
	  }
	  var attributes = "{ attrs: { " + attributePairs.join(',') + " }, props: { " + propertyPairs.join(',') + " }, on: { " + eventPairs.join(',') + " } }";
	  var h = "h('" + node.nodeName + "', " + attributes + ", $$$cleanArray([" + children.join(",") + "]))";
	  if (listExpression != null) {
	    h = createList(listExpression, h);
	  }
	  if (conditionalExpression != null) {
	    return "((" + conditionalExpression + ")===true)?" + h + ":null";
	  }
	  return h;
	}

	function createTree(document) {
	  return createTreeChild(document.body.children[0]);
	}

	function compile(html, methods) {
	  var parser = new DOMParser();
	  var dom = parser.parseFromString(html, "text/html");
	  var tree = createTree(dom);
	  var defaultFunctions = ["$classNames", "$emit", "$action"];
	  var fns = defaultFunctions.concat(Object.keys(methods));
	  var localFunctions = [];
	  var cleanArrayFn = "function $$$cleanArray(a) { var i = 0; while (i < a.length) { if (a[i] == null ) { a.splice(i, 1); } else if ( Array.isArray(a[i]) ) { var l = a[i].length; a.splice.apply(a, [i, 1].concat(a[i])); i+=l;} else { i++; } } return a; }\n";
	  for (var i = 0; i < fns.length; i++) {
	    localFunctions.push("var " + fns[i] + " = this." + fns[i] + ".bind(this);\n");
	  }
	  var compiled = Function("var h = arguments[0];\n" + localFunctions.join("") + cleanArrayFn + "return " + tree);
	  return function () {
	    if (this.$lifecycle.beforeUpdate) {
	      this.$lifecycle.beforeUpdate.call(this);
	    }
	    var newVnode = compiled.call(this, h, this.$evaluateProp.bind(this), this.$evaluateAttribute.bind(this));
	    if (newVnode == null) {
	      this.innerHTML = "";
	      return;
	    }
	    if (this.$vdom) {
	      patch(this.$vdom, newVnode);
	    } else {
	      patch(this.rootEl, newVnode);
	    }
	    this.$vdom = newVnode;
	    if (this.$lifecycle.updated) {
	      this.$lifecycle.updated.call(this);
	    }
	  };
	}

	function createAccessor(accessors, prop) {
	  accessors[prop] = {
	    set: function set(val) {
	      var oldVal = this.$props[prop];
	      if (oldVal !== val) {
	        this.$props[prop] = val;
	        if (this.$lifecycle.propertyChanged) {
	          this.$lifecycle.propertyChanged.call(this, prop, oldVal, val);
	        }
	        this.render();
	      }
	    },
	    get: function get() {
	      return this.$props[prop];
	    }
	  };
	}

	function sigil() {
	  var name = arguments[0];
	  var props = arguments[1];
	  var options = arguments[2];
	  if (_typeof(arguments[1]) === 'object' && !Array.isArray(arguments[1])) {
	    options = arguments[1];
	    props = [];
	  }
	  var html = "";
	  var currentNode = document._currentScript.parentNode;
	  html = currentNode.querySelector("#" + name).innerHTML;
	  html = "<div>" + html + "</div>";

	  var methods = {};
	  if (options && options.methods) {
	    methods = options.methods;
	  }
	  var render = compile(html, methods);

	  var accessors = {};
	  var defaults = {};
	  if (options && options.defaults) {
	    defaults = options.defaults;
	  }
	  if (props !== undefined) {
	    for (var i = 0; i < props.length; i++) {
	      createAccessor(accessors, props[i]);
	    }
	  }

	  var proto = Object.create(HTMLElement.prototype);

	  proto.createdCallback = function () {
	    this.$props = {};
	    this.$lifecycle = {};
	    this.$originalContent = [];

	    while (this.childNodes.length > 0) {
	      var child = this.childNodes[0];
	      this.$originalContent.push(child);
	      child.remove();
	    }

	    //accessors
	    for (var i in accessors) {
	      Object.defineProperty(this, i, {
	        get: accessors[i].get.bind(this),
	        set: accessors[i].set.bind(this),
	        enumerable: true,
	        configurable: true
	      });
	    }

	    //methods
	    var allMethods = Object.assign({}, {
	      $classNames: function $classNames() {
	        return classNames.apply(null, arguments);
	      },
	      $emit: function $emit(name, data) {
	        var event = new CustomEvent(name, { 'detail': data, 'bubbles': true, 'cancelable': true });
	        this.dispatchEvent(event);
	      },
	      $action: function $action(type, data) {
	        var event = new CustomEvent('action', { 'detail': { type: type, data: data }, 'bubbles': true, 'cancelable': true });
	        this.dispatchEvent(event);
	      },
	      $evaluateProp: function $evaluateProp(prop) {
	        var val = this.$props[prop];
	        if (val === undefined || val === null) {
	          return "";
	        }
	        return val;
	      },
	      $evaluateAttribute: function $evaluateAttribute(attr) {
	        var attr = this.getAttribute(attr);
	        if (attr === undefined || attr === null) {
	          return "";
	        }
	        return attr;
	      }
	    }, methods);

	    for (var i in allMethods) {
	      this[i] = allMethods[i].bind(this);
	    }

	    for (var i in defaults) {
	      this.$props[i] = defaults[i];
	    }

	    if (options && options.lifecycle) {
	      this.$lifecycle = options.lifecycle;
	    }
	    this.rootEl = document.createElement("div");
	    this.appendChild(this.rootEl);
	    this.render = render;

	    if (this.$lifecycle.created) {
	      options.lifecycle.created.call(this);
	    }
	    this.render();
	  };

	  proto.attachedCallback = function () {
	    if (this.$lifecycle.attached) {
	      this.$lifecycle.attached.call(this);
	    }
	  }, proto.detachedCallback = function () {
	    if (this.$lifecycle.detached) {
	      this.$lifecycle.detached.call(this);
	    }
	  }, proto.attributeChangedCallback = function (attrName, oldValue, newValue) {
	    this.render();
	    if (this.$lifecycle.attributeChanged) {
	      this.$lifecycle.attributeChanged.call(this, attrName, oldValue, newValue);
	    }
	  };
	  document.registerElement(name, { prototype: proto });
	}

	sigil.use = function (defaultOptions) {
	  return function () {
	    var name = arguments[0];
	    var props = arguments[1];
	    var options = arguments[2];
	    if (_typeof(arguments[1]) === 'object' && !Array.isArray(arguments[1])) {
	      options = arguments[1];
	      props = [];
	    }
	    options = Object.assign(options, defaultOptions);
	    return sigil(name, props, options);
	  };
	};

	module.exports = sigil;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	(function (f) {
	  if (( false ? "undefined" : _typeof(exports)) === "object" && typeof module !== "undefined") {
	    module.exports = f();
	  } else if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else {
	    var g;if (typeof window !== "undefined") {
	      g = window;
	    } else if (typeof global !== "undefined") {
	      g = global;
	    } else if (typeof self !== "undefined") {
	      g = self;
	    } else {
	      g = this;
	    }g.snabbdom = f();
	  }
	})(function () {
	  var define, module, exports;return function e(t, n, r) {
	    function s(o, u) {
	      if (!n[o]) {
	        if (!t[o]) {
	          var a = typeof require == "function" && require;if (!u && a) return require(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
	        }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
	          var n = t[o][1][e];return s(n ? n : e);
	        }, l, l.exports, e, t, n, r);
	      }return n[o].exports;
	    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
	      s(r[o]);
	    }return s;
	  }({ 1: [function (require, module, exports) {
	      function createElement(tagName) {
	        return document.createElement(tagName);
	      }

	      function createElementNS(namespaceURI, qualifiedName) {
	        return document.createElementNS(namespaceURI, qualifiedName);
	      }

	      function createTextNode(text) {
	        return document.createTextNode(text);
	      }

	      function insertBefore(parentNode, newNode, referenceNode) {
	        parentNode.insertBefore(newNode, referenceNode);
	      }

	      function removeChild(node, child) {
	        node.removeChild(child);
	      }

	      function appendChild(node, child) {
	        node.appendChild(child);
	      }

	      function parentNode(node) {
	        return node.parentElement;
	      }

	      function nextSibling(node) {
	        return node.nextSibling;
	      }

	      function tagName(node) {
	        return node.tagName;
	      }

	      function setTextContent(node, text) {
	        node.textContent = text;
	      }

	      module.exports = {
	        createElement: createElement,
	        createElementNS: createElementNS,
	        createTextNode: createTextNode,
	        appendChild: appendChild,
	        removeChild: removeChild,
	        insertBefore: insertBefore,
	        parentNode: parentNode,
	        nextSibling: nextSibling,
	        tagName: tagName,
	        setTextContent: setTextContent
	      };
	    }, {}], 2: [function (require, module, exports) {
	      module.exports = {
	        array: Array.isArray,
	        primitive: function primitive(s) {
	          return typeof s === 'string' || typeof s === 'number';
	        }
	      };
	    }, {}], 3: [function (require, module, exports) {
	      // jshint newcap: false
	      /* global require, module, document, Node */
	      'use strict';

	      var VNode = require('./vnode');
	      var is = require('./is');
	      var domApi = require('./htmldomapi');

	      function isUndef(s) {
	        return s === undefined;
	      }
	      function isDef(s) {
	        return s !== undefined;
	      }

	      var emptyNode = VNode('', {}, [], undefined, undefined);

	      function sameVnode(vnode1, vnode2) {
	        return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
	      }

	      function createKeyToOldIdx(children, beginIdx, endIdx) {
	        var i,
	            map = {},
	            key;
	        for (i = beginIdx; i <= endIdx; ++i) {
	          key = children[i].key;
	          if (isDef(key)) map[key] = i;
	        }
	        return map;
	      }

	      var hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];

	      function init(modules, api) {
	        var i,
	            j,
	            cbs = {};

	        if (isUndef(api)) api = domApi;

	        for (i = 0; i < hooks.length; ++i) {
	          cbs[hooks[i]] = [];
	          for (j = 0; j < modules.length; ++j) {
	            if (modules[j][hooks[i]] !== undefined) cbs[hooks[i]].push(modules[j][hooks[i]]);
	          }
	        }

	        function emptyNodeAt(elm) {
	          var id = elm.id ? '#' + elm.id : '';
	          var c = elm.className ? '.' + elm.className.split(' ').join('.') : '';
	          return VNode(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);
	        }

	        function createRmCb(childElm, listeners) {
	          return function () {
	            if (--listeners === 0) {
	              var parent = api.parentNode(childElm);
	              api.removeChild(parent, childElm);
	            }
	          };
	        }

	        function createElm(vnode, insertedVnodeQueue) {
	          var i,
	              data = vnode.data;
	          if (isDef(data)) {
	            if (isDef(i = data.hook) && isDef(i = i.init)) {
	              i(vnode);
	              data = vnode.data;
	            }
	          }
	          var elm,
	              children = vnode.children,
	              sel = vnode.sel;
	          if (isDef(sel)) {
	            // Parse selector
	            var hashIdx = sel.indexOf('#');
	            var dotIdx = sel.indexOf('.', hashIdx);
	            var hash = hashIdx > 0 ? hashIdx : sel.length;
	            var dot = dotIdx > 0 ? dotIdx : sel.length;
	            var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
	            elm = vnode.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag) : api.createElement(tag);
	            if (hash < dot) elm.id = sel.slice(hash + 1, dot);
	            if (dotIdx > 0) elm.className = sel.slice(dot + 1).replace(/\./g, ' ');
	            if (is.array(children)) {
	              for (i = 0; i < children.length; ++i) {
	                api.appendChild(elm, createElm(children[i], insertedVnodeQueue));
	              }
	            } else if (is.primitive(vnode.text)) {
	              api.appendChild(elm, api.createTextNode(vnode.text));
	            }
	            for (i = 0; i < cbs.create.length; ++i) {
	              cbs.create[i](emptyNode, vnode);
	            }i = vnode.data.hook; // Reuse variable
	            if (isDef(i)) {
	              if (i.create) i.create(emptyNode, vnode);
	              if (i.insert) insertedVnodeQueue.push(vnode);
	            }
	          } else {
	            elm = vnode.elm = api.createTextNode(vnode.text);
	          }
	          return vnode.elm;
	        }

	        function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
	          for (; startIdx <= endIdx; ++startIdx) {
	            api.insertBefore(parentElm, createElm(vnodes[startIdx], insertedVnodeQueue), before);
	          }
	        }

	        function invokeDestroyHook(vnode) {
	          var i,
	              j,
	              data = vnode.data;
	          if (isDef(data)) {
	            if (isDef(i = data.hook) && isDef(i = i.destroy)) i(vnode);
	            for (i = 0; i < cbs.destroy.length; ++i) {
	              cbs.destroy[i](vnode);
	            }if (isDef(i = vnode.children)) {
	              for (j = 0; j < vnode.children.length; ++j) {
	                invokeDestroyHook(vnode.children[j]);
	              }
	            }
	          }
	        }

	        function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
	          for (; startIdx <= endIdx; ++startIdx) {
	            var i,
	                listeners,
	                rm,
	                ch = vnodes[startIdx];
	            if (isDef(ch)) {
	              if (isDef(ch.sel)) {
	                invokeDestroyHook(ch);
	                listeners = cbs.remove.length + 1;
	                rm = createRmCb(ch.elm, listeners);
	                for (i = 0; i < cbs.remove.length; ++i) {
	                  cbs.remove[i](ch, rm);
	                }if (isDef(i = ch.data) && isDef(i = i.hook) && isDef(i = i.remove)) {
	                  i(ch, rm);
	                } else {
	                  rm();
	                }
	              } else {
	                // Text node
	                api.removeChild(parentElm, ch.elm);
	              }
	            }
	          }
	        }

	        function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
	          var oldStartIdx = 0,
	              newStartIdx = 0;
	          var oldEndIdx = oldCh.length - 1;
	          var oldStartVnode = oldCh[0];
	          var oldEndVnode = oldCh[oldEndIdx];
	          var newEndIdx = newCh.length - 1;
	          var newStartVnode = newCh[0];
	          var newEndVnode = newCh[newEndIdx];
	          var oldKeyToIdx, idxInOld, elmToMove, before;

	          while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
	            if (isUndef(oldStartVnode)) {
	              oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
	            } else if (isUndef(oldEndVnode)) {
	              oldEndVnode = oldCh[--oldEndIdx];
	            } else if (sameVnode(oldStartVnode, newStartVnode)) {
	              patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
	              oldStartVnode = oldCh[++oldStartIdx];
	              newStartVnode = newCh[++newStartIdx];
	            } else if (sameVnode(oldEndVnode, newEndVnode)) {
	              patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
	              oldEndVnode = oldCh[--oldEndIdx];
	              newEndVnode = newCh[--newEndIdx];
	            } else if (sameVnode(oldStartVnode, newEndVnode)) {
	              // Vnode moved right
	              patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
	              api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
	              oldStartVnode = oldCh[++oldStartIdx];
	              newEndVnode = newCh[--newEndIdx];
	            } else if (sameVnode(oldEndVnode, newStartVnode)) {
	              // Vnode moved left
	              patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
	              api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
	              oldEndVnode = oldCh[--oldEndIdx];
	              newStartVnode = newCh[++newStartIdx];
	            } else {
	              if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
	              idxInOld = oldKeyToIdx[newStartVnode.key];
	              if (isUndef(idxInOld)) {
	                // New element
	                api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
	                newStartVnode = newCh[++newStartIdx];
	              } else {
	                elmToMove = oldCh[idxInOld];
	                patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
	                oldCh[idxInOld] = undefined;
	                api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
	                newStartVnode = newCh[++newStartIdx];
	              }
	            }
	          }
	          if (oldStartIdx > oldEndIdx) {
	            before = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
	            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
	          } else if (newStartIdx > newEndIdx) {
	            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
	          }
	        }

	        function patchVnode(oldVnode, vnode, insertedVnodeQueue) {
	          var i, hook;
	          if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {
	            i(oldVnode, vnode);
	          }
	          var elm = vnode.elm = oldVnode.elm,
	              oldCh = oldVnode.children,
	              ch = vnode.children;
	          if (oldVnode === vnode) return;
	          if (!sameVnode(oldVnode, vnode)) {
	            var parentElm = api.parentNode(oldVnode.elm);
	            elm = createElm(vnode, insertedVnodeQueue);
	            api.insertBefore(parentElm, elm, oldVnode.elm);
	            removeVnodes(parentElm, [oldVnode], 0, 0);
	            return;
	          }
	          if (isDef(vnode.data)) {
	            for (i = 0; i < cbs.update.length; ++i) {
	              cbs.update[i](oldVnode, vnode);
	            }i = vnode.data.hook;
	            if (isDef(i) && isDef(i = i.update)) i(oldVnode, vnode);
	          }
	          if (isUndef(vnode.text)) {
	            if (isDef(oldCh) && isDef(ch)) {
	              if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);
	            } else if (isDef(ch)) {
	              if (isDef(oldVnode.text)) api.setTextContent(elm, '');
	              addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
	            } else if (isDef(oldCh)) {
	              removeVnodes(elm, oldCh, 0, oldCh.length - 1);
	            } else if (isDef(oldVnode.text)) {
	              api.setTextContent(elm, '');
	            }
	          } else if (oldVnode.text !== vnode.text) {
	            api.setTextContent(elm, vnode.text);
	          }
	          if (isDef(hook) && isDef(i = hook.postpatch)) {
	            i(oldVnode, vnode);
	          }
	        }

	        return function (oldVnode, vnode) {
	          var i, elm, parent;
	          var insertedVnodeQueue = [];
	          for (i = 0; i < cbs.pre.length; ++i) {
	            cbs.pre[i]();
	          }if (isUndef(oldVnode.sel)) {
	            oldVnode = emptyNodeAt(oldVnode);
	          }

	          if (sameVnode(oldVnode, vnode)) {
	            patchVnode(oldVnode, vnode, insertedVnodeQueue);
	          } else {
	            elm = oldVnode.elm;
	            parent = api.parentNode(elm);

	            createElm(vnode, insertedVnodeQueue);

	            if (parent !== null) {
	              api.insertBefore(parent, vnode.elm, api.nextSibling(elm));
	              removeVnodes(parent, [oldVnode], 0, 0);
	            }
	          }

	          for (i = 0; i < insertedVnodeQueue.length; ++i) {
	            insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
	          }
	          for (i = 0; i < cbs.post.length; ++i) {
	            cbs.post[i]();
	          }return vnode;
	        };
	      }

	      module.exports = { init: init };
	    }, { "./htmldomapi": 1, "./is": 2, "./vnode": 4 }], 4: [function (require, module, exports) {
	      module.exports = function (sel, data, children, text, elm) {
	        var key = data === undefined ? undefined : data.key;
	        return { sel: sel, data: data, children: children,
	          text: text, elm: elm, key: key };
	      };
	    }, {}] }, {}, [3])(3);
	});

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	(function (f) {
	  if (( false ? "undefined" : _typeof(exports)) === "object" && typeof module !== "undefined") {
	    module.exports = f();
	  } else if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else {
	    var g;if (typeof window !== "undefined") {
	      g = window;
	    } else if (typeof global !== "undefined") {
	      g = global;
	    } else if (typeof self !== "undefined") {
	      g = self;
	    } else {
	      g = this;
	    }g.h = f();
	  }
	})(function () {
	  var define, module, exports;return function e(t, n, r) {
	    function s(o, u) {
	      if (!n[o]) {
	        if (!t[o]) {
	          var a = typeof require == "function" && require;if (!u && a) return require(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
	        }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
	          var n = t[o][1][e];return s(n ? n : e);
	        }, l, l.exports, e, t, n, r);
	      }return n[o].exports;
	    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
	      s(r[o]);
	    }return s;
	  }({ 1: [function (require, module, exports) {
	      var VNode = require('./vnode');
	      var is = require('./is');

	      function addNS(data, children, sel) {
	        data.ns = 'http://www.w3.org/2000/svg';

	        if (sel !== 'foreignObject' && children !== undefined) {
	          for (var i = 0; i < children.length; ++i) {
	            addNS(children[i].data, children[i].children, children[i].sel);
	          }
	        }
	      }

	      module.exports = function h(sel, b, c) {
	        var data = {},
	            children,
	            text,
	            i;
	        if (c !== undefined) {
	          data = b;
	          if (is.array(c)) {
	            children = c;
	          } else if (is.primitive(c)) {
	            text = c;
	          }
	        } else if (b !== undefined) {
	          if (is.array(b)) {
	            children = b;
	          } else if (is.primitive(b)) {
	            text = b;
	          } else {
	            data = b;
	          }
	        }
	        if (is.array(children)) {
	          for (i = 0; i < children.length; ++i) {
	            if (is.primitive(children[i])) children[i] = VNode(undefined, undefined, undefined, children[i]);
	          }
	        }
	        if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g') {
	          addNS(data, children, sel);
	        }
	        return VNode(sel, data, children, text, undefined);
	      };
	    }, { "./is": 2, "./vnode": 3 }], 2: [function (require, module, exports) {
	      module.exports = {
	        array: Array.isArray,
	        primitive: function primitive(s) {
	          return typeof s === 'string' || typeof s === 'number';
	        }
	      };
	    }, {}], 3: [function (require, module, exports) {
	      module.exports = function (sel, data, children, text, elm) {
	        var key = data === undefined ? undefined : data.key;
	        return { sel: sel, data: data, children: children,
	          text: text, elm: elm, key: key };
	      };
	    }, {}] }, {}, [1])(1);
	});

/***/ },
/* 3 */
/***/ function(module, exports) {

	'use strict';

	function updateProps(oldVnode, vnode) {
	  var key,
	      cur,
	      old,
	      elm = vnode.elm,
	      oldProps = oldVnode.data.props,
	      props = vnode.data.props;

	  if (!oldProps && !props) return;
	  oldProps = oldProps || {};
	  props = props || {};

	  for (key in oldProps) {
	    if (!props[key]) {
	      delete elm[key];
	    }
	  }
	  for (key in props) {
	    cur = props[key];
	    old = oldProps[key];
	    if (old !== cur && (key !== 'value' || elm[key] !== cur)) {
	      elm[key] = cur;
	    }
	  }
	}

	var PropertyModule = { create: updateProps, update: updateProps };

	module.exports = PropertyModule;

/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";

	var NamespaceURIs = {
	  "xlink": "http://www.w3.org/1999/xlink"
	};

	var booleanAttrs = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "compact", "controls", "declare", "default", "defaultchecked", "defaultmuted", "defaultselected", "defer", "disabled", "draggable", "enabled", "formnovalidate", "hidden", "indeterminate", "inert", "ismap", "itemscope", "loop", "multiple", "muted", "nohref", "noresize", "noshade", "novalidate", "nowrap", "open", "pauseonexit", "readonly", "required", "reversed", "scoped", "seamless", "selected", "sortable", "spellcheck", "translate", "truespeed", "typemustmatch", "visible"];

	var booleanAttrsDict = Object.create(null);
	for (var i = 0, len = booleanAttrs.length; i < len; i++) {
	  booleanAttrsDict[booleanAttrs[i]] = true;
	}

	function updateAttrs(oldVnode, vnode) {
	  var key,
	      cur,
	      old,
	      elm = vnode.elm,
	      oldAttrs = oldVnode.data.attrs,
	      attrs = vnode.data.attrs,
	      namespaceSplit;

	  if (!oldAttrs && !attrs) return;
	  oldAttrs = oldAttrs || {};
	  attrs = attrs || {};

	  // update modified attributes, add new attributes
	  for (key in attrs) {
	    cur = attrs[key];
	    old = oldAttrs[key];
	    if (old !== cur) {
	      if (!cur && booleanAttrsDict[key]) elm.removeAttribute(key);else {
	        namespaceSplit = key.split(":");
	        if (namespaceSplit.length > 1 && NamespaceURIs.hasOwnProperty(namespaceSplit[0])) elm.setAttributeNS(NamespaceURIs[namespaceSplit[0]], key, cur);else elm.setAttribute(key, cur);
	      }
	    }
	  }
	  //remove removed attributes
	  // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)
	  // the other option is to remove all attributes with value == undefined
	  for (key in oldAttrs) {
	    if (!(key in attrs)) {
	      elm.removeAttribute(key);
	    }
	  }
	}

	var AttributesModule = { create: updateAttrs, update: updateAttrs };

	module.exports = AttributesModule;

/***/ },
/* 5 */
/***/ function(module, exports) {

	"use strict";

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	function invokeHandler(handler, vnode, event) {
	  if (typeof handler === "function") {
	    // call function handler
	    handler.call(vnode, event, vnode);
	  } else if ((typeof handler === "undefined" ? "undefined" : _typeof(handler)) === "object") {
	    // call handler with arguments
	    if (typeof handler[0] === "function") {
	      // special case for single argument for performance
	      if (handler.length === 2) {
	        handler[0].call(vnode, handler[1], event, vnode);
	      } else {
	        var args = handler.slice(1);
	        args.push(event);
	        args.push(vnode);
	        handler[0].apply(vnode, args);
	      }
	    } else {
	      // call multiple handlers
	      for (var i = 0; i < handler.length; i++) {
	        invokeHandler(handler[i]);
	      }
	    }
	  }
	}

	function handleEvent(event, vnode) {
	  var name = event.type,
	      on = vnode.data.on;

	  // call event handler(s) if exists
	  if (on && on[name]) {
	    invokeHandler(on[name], vnode, event);
	  }
	}

	function createListener() {
	  return function handler(event) {
	    handleEvent(event, handler.vnode);
	  };
	}

	function updateEventListeners(oldVnode, vnode) {
	  var oldOn = oldVnode.data.on,
	      oldListener = oldVnode.listener,
	      oldElm = oldVnode.elm,
	      on = vnode && vnode.data.on,
	      elm = vnode && vnode.elm,
	      name;

	  // optimization for reused immutable handlers
	  if (oldOn === on) {
	    return;
	  }

	  // remove existing listeners which no longer used
	  if (oldOn && oldListener) {
	    // if element changed or deleted we remove all existing listeners unconditionally
	    if (!on) {
	      for (name in oldOn) {
	        // remove listener if element was changed or existing listeners removed
	        oldElm.removeEventListener(name, oldListener, false);
	      }
	    } else {
	      for (name in oldOn) {
	        // remove listener if existing listener removed
	        if (!on[name]) {
	          oldElm.removeEventListener(name, oldListener, false);
	        }
	      }
	    }
	  }

	  // add new listeners which has not already attached
	  if (on) {
	    // reuse existing listener or create new
	    var listener = vnode.listener = oldVnode.listener || createListener();
	    // update vnode for listener
	    listener.vnode = vnode;

	    // if element changed or added we add all needed listeners unconditionally
	    if (!oldOn) {
	      for (name in on) {
	        // add listener if element was changed or new listeners added
	        elm.addEventListener(name, listener, false);
	      }
	    } else {
	      for (name in on) {
	        // add listener if new listener added
	        if (!oldOn[name]) {
	          elm.addEventListener(name, listener, false);
	        }
	      }
	    }
	  }
	}

	var EventListenersModule = {
	  create: updateEventListeners,
	  update: updateEventListeners,
	  destroy: updateEventListeners
	};

	module.exports = EventListenersModule;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */

	(function () {
		'use strict';

		var hasOwn = {}.hasOwnProperty;

		function classNames () {
			var classes = [];

			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;

				var argType = typeof arg;

				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					classes.push(classNames.apply(null, arg));
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}

			return classes.join(' ');
		}

		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		} else if (true) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	}());


/***/ }
/******/ ])
});
;